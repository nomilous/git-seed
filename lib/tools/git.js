// Generated by CoffeeScript 1.4.0
var Shell, colors, git, waterfall;

Shell = require('./shell');

colors = require('colors');

waterfall = require('async').waterfall;

module.exports = git = {
  showOrigin: function(workDir) {
    var gitDir;
    gitDir = git.gitDir(workDir);
    try {
      return Shell.execSync("git --git-dir=" + gitDir + " config --get remote.origin.url");
    } catch (error) {
      console.log(error.red);
      throw error;
    }
  },
  showBranch: function(workDir) {
    var gitDir;
    gitDir = git.gitDir(workDir);
    try {
      return Shell.execSync("cat " + gitDir + "/HEAD", false).match(/ref: (.*)$/)[1];
    } catch (error) {
      console.log(error.red);
      throw error;
    }
  },
  showRef: function(workDir) {
    var branch, gitDir;
    gitDir = git.gitDir(workDir);
    branch = git.showBranch(workDir);
    try {
      return Shell.execSync("cat " + gitDir + "/" + branch);
    } catch (error) {
      console.log(error.red);
      throw error;
    }
  },
  showStatus: function(workDir, log) {
    var gitDir;
    gitDir = git.gitDir(workDir);
    try {
      return Shell.execSync("git --git-dir=" + gitDir + " --work-tree=" + workDir + " status", log);
    } catch (error) {
      console.log(error.red);
      throw error;
    }
  },
  gitDir: function(workDir) {
    return workDir + '/.git';
  },
  showStagedDiffs: function(workDir) {
    return Shell.execSync("git --git-dir=" + workDir + "/.git --work-tree=" + workDir + " diff --cached", false);
  },
  hasStagedChanges: function(workDir) {
    return 0 !== git.showStagedDiffs(workDir).length;
  },
  clone: function(workDir, origin, branch, finalCallback) {
    return waterfall([
      function(callback) {
        if (Shell.gotDirectory(workDir)) {
          return callback(null);
        } else {
          return Shell.spawn('mkdir', ['-p', workDir], callback);
        }
      }, function(callback) {
        if (Shell.gotDirectory("" + workDir + "/.git")) {
          console.log('(skip)'.green, 'already cloned', workDir);
          return callback(null);
        } else {
          return Shell.spawn('git', ['clone', origin, workDir], callback);
        }
      }, function(callback) {
        if (git.showBranch(workDir) === branch) {
          return callback(null);
        } else {
          return Shell.spawn('git', ["--git-dir=" + workDir + "/.git", "--work-tree=" + workDir, 'checkout', branch.replace('refs/heads/', '')], callback);
        }
      }
    ], finalCallback);
  },
  commit: function(workDir, branch, message, finalCallback) {
    return waterfall([
      function(callback) {
        var skip;
        skip = false;
        if (Shell.gotDirectory(workDir)) {
          return callback(null, skip);
        } else {
          console.log('( SKIPPED )'.red, 'missing repo', workDir);
          return callback(null, skip = true);
        }
      }, function(skip, callback) {
        var currentBranch;
        if (skip) {
          callback(null, skip);
          return;
        }
        currentBranch = git.showBranch(workDir);
        if (currentBranch === branch) {
          return callback(null, skip);
        } else {
          console.log('( SKIPPED )'.red, workDir.bold, 'SHOULD BE ON BRANCH', branch.red, 'NOT', currentBranch.red);
          return callback(null, skip = true);
        }
      }, function(skip, callback) {
        if (skip) {
          callback(null, skip);
          return;
        }
        if (!git.hasStagedChanges(workDir)) {
          console.log('(skip)'.green, 'no staged changes in', workDir);
          callback(null);
          return;
        }
        return Shell.spawn('git', ["--git-dir=" + workDir + "/.git", "--work-tree=" + workDir, 'commit', '-m', message], callback);
      }
    ], finalCallback);
  }
};
